// SPDX-License-Identifier: GNU AGPLv3
pragma solidity ^0.8.0;

/// @title PercentageMath.
/// @author Morpho Labs.
/// @custom:contact security@morpho.xyz
/// @notice Optimized version of Aave V3 math library PercentageMath to conduct percentage manipulations: https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/math/PercentageMath.sol
library PercentageMath {
    ///	CONSTANTS ///

    uint256 internal constant PERCENTAGE_FACTOR = 1e4;
    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;
    uint256 internal constant MAX_UINT256 = 2**256 - 1;
    uint256 internal constant MAX_UINT256_MINUS_HALF_PERCENTAGE = 2**256 - 1 - 0.5e4;

    /// INTERNAL ///

    /// @notice Executes a percentage multiplication.
    /// @param x The value of which the percentage needs to be calculated.
    /// @param percentage The percentage of the value to be calculated.
    /// @return y The result of the multiplication.
    function percentMul(uint256 x, uint256 percentage) internal pure returns (uint256 y) {
        // Let percentage > 0
        // Overflow if x * percentage + HALF_PERCENTAGE_FACTOR > type(uint256).max
        // <=> x * percentage > type(uint256).max - HALF_PERCENTAGE_FACTOR
        // <=> x > (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage
        assembly {
            if and(gt(percentage, 0), gt(x, div(MAX_UINT256_MINUS_HALF_PERCENTAGE, percentage))) {
                revert(0, 0)
            }

            y := div(add(mul(x, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)
        }
    }

    /// @notice Executes a percentage division.
    /// @param x The value of which the percentage needs to be calculated.
    /// @param percentage The percentage of the value to be calculated.
    /// @return y The result of the division.
    function percentDiv(uint256 x, uint256 percentage) internal pure returns (uint256 y) {
        // let percentage > 0
        // Overflow if x * PERCENTAGE_FACTOR + halfPercentage > type(uint256).max
        // <=> x * PERCENTAGE_FACTOR > type(uint256).max - halfPercentage
        // <=> x > type(uint256).max - halfPercentage / PERCENTAGE_FACTOR
        assembly {
            y := div(percentage, 2)
            if or(iszero(percentage), gt(x, div(sub(MAX_UINT256, y), PERCENTAGE_FACTOR))) {
                revert(0, 0)
            }

            y := div(add(mul(x, PERCENTAGE_FACTOR), y), percentage)
        }
    }
}
